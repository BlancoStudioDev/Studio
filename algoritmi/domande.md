Grafi:
    Cos’è un grafo simmetrico?
    Cos’è un grafo fortemente connesso?
    Le rappresentazioni possibili di un grafo.
    Come rappresentare il grafo (es. lista di adiacenza, lista di archi, matrice di incidenza).
    I problemi dei cammini minimi nei grafi.
    Problema di cammino minimo (definizione e varianti, come distanza e cammino minimo fra tutti i vertici).
    Algoritmo di Dijkstra (ad alto livello, strategia greedy, spiegazione dettagliata e pseudocodice).
    Che operazioni si fanno sulla coda di priorità in Dijkstra?
    Kruskal applicato a un grafo non connesso: cosa si ottiene?
    Differenze fra Kruskal e Prim (tecniche greedy).
    Algoritmi per trovare l'albero ricoprente minimo: Kruskal e Prim.
    Spiegazione dell'algoritmo di Kruskal.
    Come cambia la complessità di Kruskal usando BubbleSort per ordinare gli archi.
    Algoritmi greedy che trovano sempre la soluzione ottima: Kruskal, Prim, Dijkstra.
    Definizione di albero ricoprente minimo.
    Rappresentazione di un grafo per Kruskal.
    Differenza tra lista di adiacenza e lista di archi.
    Distanza da tutti i vertici a un singolo vertice.
    Algoritmi di cammini minimi: Dijkstra, Bellman-Ford, Floyd-Warshall.
    Differenza tra Dijkstra e Bellman-Ford.
    Problemi con cicli negativi negli algoritmi di cammini minimi.
    Matrice di adiacenza e trasformazione tra rappresentazioni.
    Cosa garantisce che un grafo sia connesso (tra ogni coppia di vertici esiste un cammino).
    Relazione tra vertici e archi in un albero.

Alberi:
    Cos’è un albero ricoprente?
    Cos’è un albero ricoprente minimo?
    Gli algoritmi per trovare l’albero ricoprente minimo (Prim e Kruskal).
    Alberi come struttura dati (binari di ricerca, 2-3, B-alberi).
    Cos’è un albero binario di ricerca?
    Le condizioni di bilanciamento degli alberi binari.
    Alberi bilanciati e AVL (definizione, caratteristiche, vantaggi/svantaggi).
    Differenze fra alberi binari bilanciati e perfettamente bilanciati.
    Albero perfettamente bilanciato: definizione e costo delle operazioni.
    Inserimento e ribilanciamento in un albero AVL.
    Alberi 2-3 (definizione, caratteristiche, altezza logaritmica).
    Definizione di albero binario di ricerca.
    Come stampare i nodi di un albero binario di ricerca in ordine decrescente.
    Alberi AVL: definizione, rotazioni, e bilanciamento.
    Alberi 2-3: definizione, ricerca, inserimento, e numero di foglie.
    Alberi perfettamente bilanciati: definizione e proprietà.
    Differenze tra alberi AVL, binari di ricerca e bilanciati.
    Cosa succede se un albero si trasforma in una lista (bilanciamento lineare).
    Problemi relativi agli alberi, come l'albero ricoprente minimo.
    Definizione di albero in termini di grafi (connesso, privo di cicli).
    Struttura heap: definizione, rappresentazione come array posizionale.
    Heapsort: implementazione, complessità, e utilizzo.

Algoritmi di Ordinamento:
    Quando un algoritmo di ordinamento è detto stabile?
    Il mergesort: funzionamento e complessità.
    Differenze e somiglianze fra mergesort e quicksort.
    Il quicksort: costo, casi migliori, peggiori e medi.
    Caso base di ricorsione nel quicksort.
    BubbleSort: definizione, funzionamento, costo temporale (caso migliore e peggiore).
    SelectionSort: definizione e funzionamento.
    InsertionSort: definizione e funzionamento.
    Heapsort: risorse necessarie, funzionamento e costo.
    Descrizione e funzionamento di BubbleSort, MergeSort, QuickSort, HeapSort.
    Complessità temporale di MergeSort, QuickSort, e HeapSort.
    Algoritmi di ordinamento che hanno prestazioni buone nel caso migliore.
    Differenza tra MergeSort e QuickSort.
    Algoritmi di ordinamento non basati sui confronti: esempio RadixSort.
    Confronto sul numero di operazioni nei diversi algoritmi.
    Algoritmi che usano Divide et Impera (MergeSort, QuickSort).

Strutture Dati:
    Struttura Union-Find: QuickFind, QuickUnion, compressione di cammino.
    Code di priorità: definizione, utilizzo e implementazione.
    Gestione delle collisioni nelle hash table: liste di collisione e indirizzamento aperto.
    Differenza tra coda FIFO e coda di priorità.
    Relazione tra numero di nodi e foglie in un albero binario.
    Applicazioni delle code di priorità (es. Dijkstra).
    Le code di priorità: definizione, operazioni, implementazione con heap.
    Cos’è un mini heap e condizioni in cui è un heap?
    Relazione fra heap e array (vettore posizionale e rimozione della radice).
    Operazioni sugli heap (createHeap, risistema).
    Compressione di cammino in Union-Find: quali nodi migliora?
    Strutture Union-Find: cosa sono, a cosa servono, quali operazioni ci puoi fare.
    Tabella hash: definizione, gestione delle collisioni (esterna e interna), rehashing.

Analisi degli Algoritmi:
    Complessità temporale e spaziale degli algoritmi (O(n), O(n log n), etc.).
    Differenza tra confronti e tempo negli ordinamenti.
    Algoritmi greedy: definizione e applicazioni a problemi come lo zaino.
    Costo ammortizzato in strutture dati.
    Lower bound degli algoritmi di ordinamento basati su confronti.
    Uso di tecniche come Divide et Impera e programmazione dinamica.
    Cos’è l’analisi del costo medio?
    Cosa si intende per costo ammortizzato?
    Algoritmi greedy: esempi ottimali e non.
    Differenze fra programmazione dinamica, divide et impera e algoritmi greedy.
    Equazione di ricorrenza.

